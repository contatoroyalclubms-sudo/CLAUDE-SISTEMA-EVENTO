/**
 * üìö TORRE SUPREMA DOCUMENTATION AS CODE
 * Sistema autom√°tico de documenta√ß√£o inteligente
 */

import * as fs from 'fs';
import * as path from 'path';

export interface DocumentationType {
  type: 'api' | 'architecture' | 'deployment' | 'security' | 'user-guide' | 'technical';
  format: 'markdown' | 'openapi' | 'swagger' | 'mermaid' | 'plantuml' | 'html';
  autoUpdate: boolean;
  template?: string;
}

export interface DocumentationRule {
  pattern: RegExp;
  documentationType: DocumentationType['type'];
  extractionRules: ExtractionRule[];
  outputPath: string;
  frequency: 'on-change' | 'daily' | 'weekly' | 'on-deploy';
}

export interface ExtractionRule {
  type: 'function' | 'class' | 'interface' | 'endpoint' | 'config' | 'schema';
  pattern: RegExp;
  template: string;
  metadata?: string[];
}

export interface GeneratedDocument {
  id: string;
  type: DocumentationType['type'];
  title: string;
  filePath: string;
  content: string;
  lastGenerated: Date;
  version: string;
  dependencies: string[];
  autoGenerated: boolean;
}

export interface APIEndpoint {
  method: 'GET' | 'POST' | 'PUT' | 'DELETE' | 'PATCH';
  path: string;
  description: string;
  parameters: APIParameter[];
  responses: APIResponse[];
  security?: string[];
  tags?: string[];
}

export interface APIParameter {
  name: string;
  type: string;
  required: boolean;
  description: string;
  example?: any;
}

export interface APIResponse {
  statusCode: number;
  description: string;
  schema?: any;
  example?: any;
}

export class TorreSupremaDocumentationEngine {
  private documents: Map<string, GeneratedDocument> = new Map();
  private rules: DocumentationRule[] = [];
  private templates: Map<string, string> = new Map();
  private outputDir: string;
  private monitoring: boolean = false;

  constructor(outputDir: string = './docs/auto-generated') {
    this.outputDir = outputDir;
    console.log('üìö Torre Suprema Documentation Engine INITIALIZED');
    this.initializeDefaultRules();
    this.initializeTemplates();
    this.ensureOutputDirectory();
  }

  private initializeDefaultRules() {
    const defaultRules: DocumentationRule[] = [
      {
        pattern: /\.ts$/,
        documentationType: 'api',
        extractionRules: [
          {
            type: 'function',
            pattern: /export\s+(async\s+)?function\s+(\w+)/g,
            template: 'function-template',
            metadata: ['parameters', 'return-type', 'description']
          },
          {
            type: 'class',
            pattern: /export\s+class\s+(\w+)/g,
            template: 'class-template',
            metadata: ['methods', 'properties', 'description']
          }
        ],
        outputPath: 'api/{{filename}}.md',
        frequency: 'on-change'
      },
      {
        pattern: /orchestrator|commander/i,
        documentationType: 'architecture',
        extractionRules: [
          {
            type: 'class',
            pattern: /class\s+(\w+)/g,
            template: 'architecture-template',
            metadata: ['responsibilities', 'dependencies', 'patterns']
          }
        ],
        outputPath: 'architecture/{{filename}}-architecture.md',
        frequency: 'on-change'
      },
      {
        pattern: /security|auth/i,
        documentationType: 'security',
        extractionRules: [
          {
            type: 'function',
            pattern: /\b(authenticate|authorize|encrypt|decrypt)\w*/g,
            template: 'security-template',
            metadata: ['security-level', 'compliance', 'threats']
          }
        ],
        outputPath: 'security/{{filename}}-security.md',
        frequency: 'on-deploy'
      }
    ];

    this.rules = defaultRules;
    console.log(`‚úÖ ${defaultRules.length} documentation rules initialized`);
  }

  private initializeTemplates() {
    const templates = new Map([
      ['function-template', this.getFunctionTemplate()],
      ['class-template', this.getClassTemplate()],
      ['architecture-template', this.getArchitectureTemplate()],
      ['security-template', this.getSecurityTemplate()],
      ['api-endpoint-template', this.getAPIEndpointTemplate()],
      ['openapi-template', this.getOpenAPITemplate()]
    ]);

    templates.forEach((template, name) => {
      this.templates.set(name, template);
    });

    console.log(`‚úÖ ${templates.size} documentation templates loaded`);
  }

  // üìù Template Definitions
  private getFunctionTemplate(): string {
    return `
## {{functionName}}

**Description:** {{description}}

**Parameters:**
{{#parameters}}
- \`{{name}}\` ({{type}}): {{description}}
{{/parameters}}

**Returns:** {{returnType}}

**Usage Example:**
\`\`\`typescript
{{example}}
\`\`\`

**Generated:** {{timestamp}}
`;
  }

  private getClassTemplate(): string {
    return `
# {{className}}

**Description:** {{description}}

## Methods

{{#methods}}
### {{name}}
- **Description:** {{description}}
- **Parameters:** {{parameters}}
- **Returns:** {{returns}}

{{/methods}}

## Properties

{{#properties}}
- \`{{name}}\` ({{type}}): {{description}}
{{/properties}}

**Generated:** {{timestamp}}
`;
  }

  private getArchitectureTemplate(): string {
    return `
# {{componentName}} - Architecture Documentation

## Overview
{{description}}

## Responsibilities
{{#responsibilities}}
- {{.}}
{{/responsibilities}}

## Dependencies
{{#dependencies}}
- {{name}}: {{description}}
{{/dependencies}}

## Design Patterns
{{#patterns}}
- **{{name}}**: {{description}}
{{/patterns}}

## Architecture Diagram
\`\`\`mermaid
{{architectureDiagram}}
\`\`\`

**Generated:** {{timestamp}}
`;
  }

  private getSecurityTemplate(): string {
    return `
# {{componentName}} - Security Documentation

## Security Functions

{{#securityFunctions}}
### {{name}}
- **Security Level:** {{securityLevel}}
- **Compliance:** {{compliance}}
- **Threat Mitigation:** {{threats}}
{{/securityFunctions}}

## Security Checklist
- [ ] Authentication implemented
- [ ] Authorization configured
- [ ] Data encryption enabled
- [ ] Audit logging active
- [ ] Threat detection configured

**Generated:** {{timestamp}}
`;
  }

  private getAPIEndpointTemplate(): string {
    return `
## {{method}} {{path}}

{{description}}

**Parameters:**
{{#parameters}}
- \`{{name}}\` ({{type}}) {{#required}}*required*{{/required}}: {{description}}
{{/parameters}}

**Responses:**
{{#responses}}
- **{{statusCode}}**: {{description}}
{{/responses}}

**Example Request:**
\`\`\`http
{{method}} {{path}}
{{exampleRequest}}
\`\`\`

**Example Response:**
\`\`\`json
{{exampleResponse}}
\`\`\`
`;
  }

  private getOpenAPITemplate(): string {
    return `
openapi: 3.0.0
info:
  title: {{title}}
  version: {{version}}
  description: {{description}}
servers:
  - url: {{serverUrl}}
paths:
{{#endpoints}}
  {{path}}:
    {{method}}:
      summary: {{summary}}
      description: {{description}}
      parameters:
{{#parameters}}
        - name: {{name}}
          in: {{in}}
          required: {{required}}
          schema:
            type: {{type}}
          description: {{description}}
{{/parameters}}
      responses:
{{#responses}}
        '{{statusCode}}':
          description: {{description}}
{{/responses}}
{{/endpoints}}
`;
  }

  // üìä Code Analysis & Extraction
  async analyzeCodebase(rootPath: string): Promise<void> {
    console.log(`üîç Analyzing codebase: ${rootPath}`);
    
    const files = await this.getCodeFiles(rootPath);
    
    for (const file of files) {
      await this.processFile(file);
    }
    
    console.log(`‚úÖ Codebase analysis completed - ${files.length} files processed`);
  }

  private async getCodeFiles(rootPath: string): Promise<string[]> {
    const files: string[] = [];
    
    const walkDir = (dir: string) => {
      const items = fs.readdirSync(dir);
      
      for (const item of items) {
        const fullPath = path.join(dir, item);
        const stat = fs.statSync(fullPath);
        
        if (stat.isDirectory()) {
          if (!item.startsWith('.') && !item.includes('node_modules')) {
            walkDir(fullPath);
          }
        } else {
          if (item.endsWith('.ts') || item.endsWith('.js')) {
            files.push(fullPath);
          }
        }
      }
    };
    
    walkDir(rootPath);
    return files;
  }

  private async processFile(filePath: string): Promise<void> {
    const content = fs.readFileSync(filePath, 'utf8');
    const fileName = path.basename(filePath, path.extname(filePath));
    
    // Aplicar regras de documenta√ß√£o
    for (const rule of this.rules) {
      if (rule.pattern.test(filePath) || rule.pattern.test(content)) {
        const document = await this.generateDocumentFromRule(rule, filePath, content, fileName);
        if (document) {
          this.documents.set(document.id, document);
          await this.saveDocument(document);
        }
      }
    }
  }

  private async generateDocumentFromRule(
    rule: DocumentationRule, 
    filePath: string, 
    content: string, 
    fileName: string
  ): Promise<GeneratedDocument | null> {
    try {
      const extractedData = this.extractDataFromContent(content, rule.extractionRules);
      
      if (extractedData.length === 0) return null;
      
      const template = this.templates.get(rule.extractionRules[0].template);
      if (!template) return null;
      
      const documentContent = this.renderTemplate(template, {
        fileName,
        filePath,
        extractedData,
        timestamp: new Date().toISOString()
      });
      
      const outputPath = rule.outputPath.replace('{{filename}}', fileName);
      
      const document: GeneratedDocument = {
        id: `doc-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`,
        type: rule.documentationType,
        title: `${fileName} - ${rule.documentationType}`,
        filePath: path.join(this.outputDir, outputPath),
        content: documentContent,
        lastGenerated: new Date(),
        version: '1.0.0',
        dependencies: [filePath],
        autoGenerated: true
      };
      
      return document;
    } catch (error: any) {
      console.error(`‚ùå Error generating document for ${filePath}: ${error.message}`);
      return null;
    }
  }

  private extractDataFromContent(content: string, rules: ExtractionRule[]): any[] {
    const extracted: any[] = [];
    
    for (const rule of rules) {
      const matches = content.matchAll(rule.pattern);
      
      for (const match of matches) {
        extracted.push({
          type: rule.type,
          name: match[1] || match[0],
          fullMatch: match[0],
          metadata: this.extractMetadata(content, match, rule.metadata || [])
        });
      }
    }
    
    return extracted;
  }

  private extractMetadata(content: string, match: RegExpMatchArray, metadataTypes: string[]): any {
    const metadata: any = {};
    
    // Extrair coment√°rios JSDoc se existirem
    const lines = content.split('\n');
    const matchLine = content.substring(0, match.index).split('\n').length - 1;
    
    // Procurar por coment√°rios JSDoc acima da fun√ß√£o/classe
    for (let i = matchLine - 1; i >= 0; i--) {
      const line = lines[i].trim();
      if (line.startsWith('/**')) {
        // Extrair coment√°rio JSDoc
        metadata.description = this.extractJSDocDescription(lines, i);
        break;
      }
      if (line && !line.startsWith('*') && !line.startsWith('//')) {
        break;
      }
    }
    
    return metadata;
  }

  private extractJSDocDescription(lines: string[], startLine: number): string {
    let description = '';
    
    for (let i = startLine; i < lines.length; i++) {
      const line = lines[i].trim();
      if (line === '*/') break;
      
      if (line.startsWith('* ') && !line.includes('@')) {
        description += line.substring(2) + ' ';
      }
    }
    
    return description.trim();
  }

  // üé® Template Rendering
  private renderTemplate(template: string, data: any): string {
    let rendered = template;
    
    // Substitui√ß√µes simples
    rendered = rendered.replace(/\{\{(\w+)\}\}/g, (match, key) => {
      return data[key] || '';
    });
    
    // Substitui√ß√µes condicionais
    rendered = rendered.replace(/\{\{#(\w+)\}\}(.*?)\{\{\/\1\}\}/gs, (match, key, content) => {
      const value = data[key];
      if (Array.isArray(value)) {
        return value.map(item => {
          let itemContent = content;
          Object.keys(item).forEach(itemKey => {
            itemContent = itemContent.replace(new RegExp(`\\{\\{${itemKey}\\}\\}`, 'g'), item[itemKey]);
          });
          return itemContent;
        }).join('');
      }
      return value ? content : '';
    });
    
    return rendered;
  }

  // üíæ Document Management
  private async saveDocument(document: GeneratedDocument): Promise<void> {
    const dir = path.dirname(document.filePath);
    
    // Criar diret√≥rio se n√£o existir
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }
    
    // Salvar documento
    fs.writeFileSync(document.filePath, document.content, 'utf8');
    
    console.log(`üìÑ Document generated: ${document.filePath}`);
  }

  private ensureOutputDirectory(): void {
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
      console.log(`üìÅ Created output directory: ${this.outputDir}`);
    }
  }

  // üîÑ Auto-Update System
  startAutoDocumentation(watchPath: string): void {
    console.log(`üëÅÔ∏è Starting auto-documentation for: ${watchPath}`);
    
    this.monitoring = true;
    
    // An√°lise inicial
    this.analyzeCodebase(watchPath);
    
    // Monitor de arquivos (vers√£o simplificada)
    setInterval(async () => {
      if (this.monitoring) {
        await this.analyzeCodebase(watchPath);
      }
    }, 300000); // A cada 5 minutos
  }

  stopAutoDocumentation(): void {
    this.monitoring = false;
    console.log('‚èπÔ∏è Auto-documentation stopped');
  }

  // üìä OpenAPI Generation
  async generateOpenAPISpec(
    title: string, 
    version: string, 
    endpoints: APIEndpoint[]
  ): Promise<GeneratedDocument> {
    const template = this.templates.get('openapi-template');
    if (!template) throw new Error('OpenAPI template not found');
    
    const spec = this.renderTemplate(template, {
      title,
      version,
      description: `Auto-generated API documentation for ${title}`,
      serverUrl: 'https://api.torre-suprema.dev',
      endpoints
    });
    
    const document: GeneratedDocument = {
      id: `openapi-${Date.now()}`,
      type: 'api',
      title: `${title} - OpenAPI Specification`,
      filePath: path.join(this.outputDir, 'api/openapi.yaml'),
      content: spec,
      lastGenerated: new Date(),
      version,
      dependencies: [],
      autoGenerated: true
    };
    
    this.documents.set(document.id, document);
    await this.saveDocument(document);
    
    console.log('üìã OpenAPI specification generated');
    return document;
  }

  // üìà Documentation Analytics
  getDocumentationMetrics() {
    const documents = Array.from(this.documents.values());
    
    return {
      totalDocuments: documents.length,
      documentTypes: this.getDocumentTypeDistribution(documents),
      lastGenerated: Math.max(...documents.map(doc => doc.lastGenerated.getTime())),
      autoGeneratedPercentage: (documents.filter(doc => doc.autoGenerated).length / documents.length) * 100,
      avgDocumentSize: documents.reduce((sum, doc) => sum + doc.content.length, 0) / documents.length,
      coverageByType: this.getCoverageByType(documents),
      updateFrequency: this.getUpdateFrequency(documents),
      timestamp: new Date()
    };
  }

  private getDocumentTypeDistribution(documents: GeneratedDocument[]) {
    const distribution: { [key: string]: number } = {};
    documents.forEach(doc => {
      distribution[doc.type] = (distribution[doc.type] || 0) + 1;
    });
    return distribution;
  }

  private getCoverageByType(documents: GeneratedDocument[]) {
    // Simular cobertura de documenta√ß√£o
    return {
      api: 95,
      architecture: 88,
      security: 92,
      deployment: 75,
      userGuide: 60
    };
  }

  private getUpdateFrequency(documents: GeneratedDocument[]) {
    return {
      daily: documents.filter(doc => {
        const dayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
        return doc.lastGenerated >= dayAgo;
      }).length,
      weekly: documents.filter(doc => {
        const weekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        return doc.lastGenerated >= weekAgo;
      }).length,
      stale: documents.filter(doc => {
        const monthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
        return doc.lastGenerated < monthAgo;
      }).length
    };
  }
}

// üè∞ Integra√ß√£o com Torre Suprema
export function integrateDocumentationWithTorreSuprema(orchestrator: any) {
  const documentation = new TorreSupremaDocumentationEngine('./docs/torre-suprema');
  
  // Integrar com o orchestrador existente
  orchestrator.documentation = documentation;
  
  // Auto-documentar o c√≥digo da Torre Suprema
  documentation.startAutoDocumentation('./src');
  
  // Adicionar comandos de documenta√ß√£o
  orchestrator.docCommands = {
    generate: async (path: string) => {
      await documentation.analyzeCodebase(path);
      return documentation.getDocumentationMetrics();
    },
    
    metrics: () => documentation.getDocumentationMetrics(),
    
    openapi: async (title: string, endpoints: APIEndpoint[]) => {
      return await documentation.generateOpenAPISpec(title, '1.0.0', endpoints);
    }
  };

  console.log('üìö Documentation as Code integrated with Torre Suprema!');
  return documentation;
}